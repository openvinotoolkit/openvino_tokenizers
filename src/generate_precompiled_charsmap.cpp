// Copyright (C) 2018-2026 Intel Corporation
// SPDX-License-Identifier: Apache-2.0
//
// Build-time tool to generate precompiled charsmaps
// This eliminates the need for ICU runtime dependency

#include <iostream>
#include <fstream>
#include <string>
#include <iomanip>
#include "builder.h"  // from sentencepiece

struct CharsmapConfig {
    std::string normalization_form;
    bool case_fold;
    std::string identifier;
};

void init_sentencepiece_normalizer_chars_map(
    const std::string& normalization_form,
    const bool case_fold,
    sentencepiece::normalizer::Builder::CharsMap& chars_map
) {
    if (normalization_form == "identity") {
        // no need to modify chars_map
    } else if (normalization_form == "nfc") {
        sentencepiece::normalizer::Builder::BuildNFCMap(&chars_map);
    } else if (normalization_form == "nfd") {
        sentencepiece::normalizer::Builder::BuildNFDMap(&chars_map);
    } else if (normalization_form == "nfkc") {
        sentencepiece::normalizer::Builder::BuildNFKCMap(&chars_map);
    } else if (normalization_form == "nfkd") {
        sentencepiece::normalizer::Builder::BuildNFKDMap(&chars_map);
    } else {
        std::cerr << "Unsupported normalization form: " << normalization_form << std::endl;
        return;
    }
    
    if (case_fold) {
        sentencepiece::normalizer::Builder::MergeUnicodeCaseFoldMap(&chars_map);
    }
}

void write_byte_array(std::ofstream& out, const std::string& var_name, const std::string& data) {
    out << "const unsigned char " << var_name << "[] = {";
    
    for (size_t i = 0; i < data.size(); ++i) {
        if (i % 16 == 0) {
            out << "\n    ";
        }
        out << "0x" << std::hex << std::setw(2) << std::setfill('0') 
            << (static_cast<unsigned int>(static_cast<unsigned char>(data[i]))) << ",";
    }
    
    out << "\n};\n\n";
    out << "const size_t " << var_name << "_size = sizeof(" << var_name << ");\n\n";
}

int main(int argc, char* argv[]) {
    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " <output_header_file>" << std::endl;
        return 1;
    }

    std::ofstream header_file(argv[1]);
    if (!header_file.is_open()) {
        std::cerr << "Failed to open output file: " << argv[1] << std::endl;
        return 1;
    }

    // Define all normalization form and case_fold combinations we need to support
    CharsmapConfig configs[] = {
        // For CharsMapNormalization (lowercase forms)
        {"identity", true, "identity_case"},
        {"nfc", false, "nfc_nocase"},
        {"nfc", true, "nfc_case"},
        {"nfd", false, "nfd_nocase"},
        {"nfd", true, "nfd_case"},
        {"nfkc", false, "nfkc_nocase"},
        {"nfkc", true, "nfkc_case"},
        {"nfkd", false, "nfkd_nocase"},
        {"nfkd", true, "nfkd_case"},
        // For NormalizeUnicode (uppercase forms)
        {"NFC", false, "NFC_nocase"},
        {"NFD", false, "NFD_nocase"},
        {"NFKC", false, "NFKC_nocase"},
        {"NFKD", false, "NFKD_nocase"},
        // For CaseFold (only case folding, no normalization)
        {"identity", true, "casefold_only"},
    };

    // Write header guard and includes
    header_file << "// Copyright (C) 2018-2026 Intel Corporation\n";
    header_file << "// SPDX-License-Identifier: Apache-2.0\n";
    header_file << "//\n";
    header_file << "// Auto-generated file containing precompiled charsmaps\n";
    header_file << "// Generated by generate_precompiled_charsmap.cpp\n\n";
    header_file << "#pragma once\n\n";
    header_file << "#include <string>\n";
    header_file << "#include <map>\n";
    header_file << "#include <cstddef>\n\n";

    // Generate precompiled charsmap for each configuration
    for (const auto& config : configs) {
        std::cout << "Generating charsmap for: " << config.normalization_form 
                  << " (case_fold=" << (config.case_fold ? "true" : "false") << ")" << std::endl;

        sentencepiece::normalizer::Builder::CharsMap chars_map;
        
        // Handle both lowercase and uppercase normalization forms
        std::string norm_form_lower = config.normalization_form;
        for (auto& c : norm_form_lower) {
            c = std::tolower(c);
        }
        
        init_sentencepiece_normalizer_chars_map(norm_form_lower, config.case_fold, chars_map);
        
        std::string precompiled_charsmap;
        sentencepiece::normalizer::Builder::CompileCharsMap(chars_map, &precompiled_charsmap);
        
        write_byte_array(header_file, "precompiled_charsmap_" + config.identifier, precompiled_charsmap);
    }

    // Generate lookup function for CharsMapNormalization (lowercase)
    header_file << "inline std::string get_precompiled_charsmap(const std::string& normalization_form, bool case_fold) {\n";
    header_file << "    struct CharsmapKey {\n";
    header_file << "        std::string normalization_form;\n";
    header_file << "        bool case_fold;\n";
    header_file << "        bool operator<(const CharsmapKey& other) const {\n";
    header_file << "            if (normalization_form != other.normalization_form) {\n";
    header_file << "                return normalization_form < other.normalization_form;\n";
    header_file << "            }\n";
    header_file << "            return case_fold < other.case_fold;\n";
    header_file << "        }\n";
    header_file << "    };\n\n";
    
    header_file << "    static const std::map<CharsmapKey, std::string> precompiled_maps = {\n";
    
    bool first = true;
    for (const auto& config : configs) {
        // Only include lowercase normalization forms in this map
        if (config.normalization_form[0] >= 'a' && config.normalization_form[0] <= 'z') {
            if (!first) header_file << ",\n";
            header_file << "        {{\"" << config.normalization_form << "\", " 
                        << (config.case_fold ? "true" : "false") << "}, "
                        << "std::string(reinterpret_cast<const char*>(precompiled_charsmap_" 
                        << config.identifier << "), precompiled_charsmap_" << config.identifier 
                        << "_size)}";
            first = false;
        }
    }
    
    header_file << "\n    };\n\n";
    header_file << "    auto it = precompiled_maps.find({normalization_form, case_fold});\n";
    header_file << "    if (it != precompiled_maps.end()) {\n";
    header_file << "        return it->second;\n";
    header_file << "    }\n";
    header_file << "    return \"\";\n";
    header_file << "}\n\n";

    // Generate lookup function for NormalizeUnicode (uppercase)
    header_file << "inline std::string get_precompiled_unicode_normalization_charsmap(const std::string& normalization_form) {\n";
    header_file << "    static const std::map<std::string, std::string> precompiled_maps = {\n";
    
    first = true;
    for (const auto& config : configs) {
        // Only include uppercase normalization forms (NFC, NFD, NFKC, NFKD) in this map
        if (config.normalization_form[0] >= 'A' && config.normalization_form[0] <= 'Z') {
            if (!first) header_file << ",\n";
            header_file << "        {\"" << config.normalization_form << "\", "
                        << "std::string(reinterpret_cast<const char*>(precompiled_charsmap_" 
                        << config.identifier << "), precompiled_charsmap_" << config.identifier 
                        << "_size)}";
            first = false;
        }
    }
    
    header_file << "\n    };\n\n";
    header_file << "    auto it = precompiled_maps.find(normalization_form);\n";
    header_file << "    if (it != precompiled_maps.end()) {\n";
    header_file << "        return it->second;\n";
    header_file << "    }\n";
    header_file << "    return \"\";\n";
    header_file << "}\n\n";

    // Generate lookup function for CaseFold
    header_file << "inline std::string get_precompiled_casefold_charsmap() {\n";
    header_file << "    return std::string(reinterpret_cast<const char*>(precompiled_charsmap_casefold_only), precompiled_charsmap_casefold_only_size);\n";
    header_file << "}\n";

    header_file.close();
    std::cout << "Successfully generated: " << argv[1] << std::endl;
    
    return 0;
}
